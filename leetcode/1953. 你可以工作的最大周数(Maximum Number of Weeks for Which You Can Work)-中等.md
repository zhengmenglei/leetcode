# 一、题目
给你 n 个项目，编号从 0 到 n - 1 。同时给你一个整数数组 milestones ，其中每个 milestones[i] 表示第 i 个项目中的阶段任务数量。   
   
你可以按下面两个规则参与项目中的工作：   
- 每周，你将会完成 某一个 项目中的 恰好一个 阶段任务。你每周都 必须 工作。
- 在 连续的 两周中，你 不能 参与并完成同一个项目中的两个阶段任务。
   
   
一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 停止工作 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。   
   
返回在不违反上面规则的情况下你 最多 能工作多少周。   
   
**示例 1：**   
```
输入：milestones = [1,2,3]
输出：6
解释：一种可能的情形是：
- 第 1 周，你参与并完成项目 0 中的一个阶段任务。
- 第 2 周，你参与并完成项目 2 中的一个阶段任务。
- 第 3 周，你参与并完成项目 1 中的一个阶段任务。
- 第 4 周，你参与并完成项目 2 中的一个阶段任务。
- 第 5 周，你参与并完成项目 1 中的一个阶段任务。
- 第 6 周，你参与并完成项目 2 中的一个阶段任务。
总周数是 6 。
```
**示例 2：**   
```
输入：milestones = [5,2,1]
输出：7
解释：一种可能的情形是：
- 第 1 周，你参与并完成项目 0 中的一个阶段任务。
- 第 2 周，你参与并完成项目 1 中的一个阶段任务。
- 第 3 周，你参与并完成项目 0 中的一个阶段任务。
- 第 4 周，你参与并完成项目 1 中的一个阶段任务。
- 第 5 周，你参与并完成项目 0 中的一个阶段任务。
- 第 6 周，你参与并完成项目 2 中的一个阶段任务。
- 第 7 周，你参与并完成项目 0 中的一个阶段任务。
总周数是 7 。
注意，你不能在第 8 周参与完成项目 0 中的最后一个阶段任务，因为这会违反规则。
因此，项目 0 中会有一个阶段任务维持未完成状态。
```
**提示：**   
- n == milestones.length
- 1 <= n <= 10^5
- 1 <= milestones[i] <= 10^9
   
   
来源：力扣（LeetCode）   
链接：[https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work](https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work)   
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。   
# 二、分析及代码    
## 1. 贪心
### （1）思路
因为可任意安排各个项目的参与顺序，所以当且仅当其中某一项目的阶段任务数量 maxNum 超过总任务量 sum 的一半时，我们无法完成全部任务。   
   
根据这一特点，可直接结合贪心算法求解：   
- 若不存在超过任务总量一半的项目，即 maxNum * 2 <= sum 时，所有项目都可被完成，最长工作时间为 sum ；
- 若存在超过任务总量一半的项目，即 maxNum * 2 > sum 时，该项目无法被完成，最长工作时间为剩余项目总时间 * 2 + 1，即 (sum - maxNum) * 2L + 1 。
   
   
### （2）代码
```java
class Solution {
    public long numberOfWeeks(int[] milestones) {
        //求任务总数和最大的阶段任务数量
        long sum = 0L, maxNum = milestones[0];
        for (int stone : milestones) {
            sum = (long)sum + stone;
            maxNum = Math.max(maxNum, stone);
        }
        //贪心  
        return (maxNum * 2L > sum) ? (sum - maxNum) * 2L + 1 : sum; 
    }
}
```
### （3）结果
执行用时 ：3 ms，在所有 Java 提交中击败了 78.22% 的用户；    
内存消耗 ：47.5 MB，在所有 Java 提交中击败了 91.51% 的用户。      
# 三、其他
暂无。  
