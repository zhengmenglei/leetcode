# 一、题目
元素的 频数 是该元素在一个数组中出现的次数。       
给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。      
执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。      
      
**示例 1：**      
```
输入：nums = [1,2,4], k = 5
输出：3
解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。
4 是数组中最高频元素，频数是 3 。
```
**示例 2：**      
```
输入：nums = [1,4,8,13], k = 5
输出：2
解释：存在多种最优解决方案：
- 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。
- 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。
- 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。
```
**示例 3：**    
```
输入：nums = [3,9,6], k = 2
输出：1
```
**提示：**       
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^5
- 1 <= k <= 10^5
         
         
来源：力扣（LeetCode）        
链接：[https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element](https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element)         
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。        
# 二、分析及代码    
## 1. 排序 + 双指针
### （1）思路
由反证可得，在一定操作次数下最高频元素为原数组中的元素，结合贪心算法，应优先选择不大于该元素的最大数字进行递增操作。      
因此，可对原数组排序后，结合双指针算法求解。设计左、右两个指针，在移动右指针的同时，维护左指针的位置，使区间内元素全部递增到右指针所在元素值的操作次数符合要求，此时区间的长度就是该元素的频率。       
### （2）代码
```java
class Solution {
    public int maxFrequency(int[] nums, int k) {
        Arrays.sort(nums);
        int n = nums.length, ans = 1, op = 0;
        for (int l = 0, r = 1; r < n; r++) {
            op += (nums[r] - nums[r - 1]) * (r - l);//右指针移动后所需操作次数
            while (op > k)//操作次数超过k，移动左指针
                op -= nums[r] - nums[l++];
            ans = Math.max(ans, r - l + 1);//区间长度为操作后当前元素的频数
        }
        return ans;
    }
}
```
### （3）结果
执行用时 ：33 ms，在所有 Java 提交中击败了 100.00% 的用户；    
内存消耗 ：52.8 MB，在所有 Java 提交中击败了 100.00% 的用户。      
（目前提交用户量不足，暂无排名）       
# 三、其他
暂无。  
