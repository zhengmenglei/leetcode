# 一、题目
在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。     
返回所需的 K 位翻转的最小次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。     
     
**示例 1：**
```
输入：A = [0,1,0], K = 1
输出：2
解释：先翻转 A[0]，然后翻转 A[2]。
```
**示例 2：**      
```
输入：A = [1,1,0], K = 2
输出：-1
解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。
```
**示例 3：**    
```
输入：A = [0,0,0,1,0,1,1,0], K = 3
输出：3
解释：
翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]
翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]
翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]
```
**提示：**     
- 1 <= A.length <= 30000
- 1 <= K <= A.length
      
来源：力扣（LeetCode）     
链接：[https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips](https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips)     
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。     
# 二、分析及代码    
## 1. 滑动窗口
### （1）思路
根据题意，对于每一个区间，只有 1 次翻转是有效的，第 2 次就会回到初始状态。因此可从数组起始位置开始，若第 1 个元素为 0，则翻转该区间，否则窗口右移直至结束。         
若全部区间翻转完成，最后 K 个元素中仍存在 0，说明无法实现数组元素全部为 1。     
为降低复杂度，可设计一个数 flip 记录当前位置被进行过的翻转次数，翻转时同步在当前 + K 位置处进行标记，遍历到该处时再将翻转次数 -1。    
因为题中所给数组只包含 0 和 1，可以通过将数字 + 2 标记翻转区间的右边界。     
### （2）代码
```java
class Solution {
    public int minKBitFlips(int[] A, int K) {
        int n = A.length, ans = 0, flip = 0;//翻转次数
        for (int i = 0; i < n; i++) {
            flip -= A[i] >> 1;
            if (((A[i] + flip) & 1) != 1) {//目前翻转下当前位置为1无需操作
                if (i > n - K)//最后长度小于K的区间内仍有0，无法全部更改为1
                    return -1;
                if (i + K < n)//翻转了长度为K的区间，到达区间末尾后翻转次数-1
                    A[i + K] -= 2;//通过对2取模避免干扰原数组中的0和1
                flip++;//当前位置开始执行一次翻转
                ans++;//记录翻转次数
            }
        }
        return ans;
    }
}
```
### （3）结果
执行用时 ：4 ms，在所有 Java 提交中击败了 100.00% 的用户；    
内存消耗 ：46.7 MB，在所有 Java 提交中击败了 25.63% 的用户。      
# 三、其他
暂无。  
