# 一、题目
给定一个已排序的正整数数组 nums，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。   
   
**示例 1:**   
```
输入: nums = [1,3], n = 6
输出: 1 
解释:
根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。
现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。
其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。
所以我们最少需要添加一个数字。
```
**示例 2:**   
```
输入: nums = [1,5,10], n = 20
输出: 2
解释: 我们需要添加 [2, 4]。
```
**示例 3:**    
```
输入: nums = [1,2,2], n = 5
输出: 0
```
来源：力扣（LeetCode）   
链接：[https://leetcode-cn.com/problems/patching-array](https://leetcode-cn.com/problems/patching-array)   
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。   
# 二、分析及代码    
## 1. 贪心算法
### （1）思路
首先发现一个规律：如果 [1, x] 区间内的数字可以表示为现有数字的和，则添加数字 y 后，[1, x + y] 区间内的数字都将可以被表示。   
设计一个 sum 值用于记录当前区间右边界，根据 sum 和现有数字的大小关系，通过给定数组或添加的数字扩展 sum 边界，直至达到符合题目要求的 n。    
### （2）代码
```Java
class Solution {
    public int minPatches(int[] nums, int n) {
        int ans = 0, j = 0;//当前遍历到的 nums 索引
        long sum = 0;//避免超过 int 范围时溢出

        while (sum < n) {
            if (j < nums.length && nums[j] <= sum + 1)
                sum += nums[j++];
            else {
                sum = sum * 2 + 1;
                ans++;
            }
        }

        return ans;
    }
}
```
### （3）结果
执行用时 ：0 ms，在所有 Java 提交中击败了 100.00% 的用户；    
内存消耗 ：38.2 MB，在所有 Java 提交中击败了 48.95% 的用户。      
# 三、其他
暂无。  
