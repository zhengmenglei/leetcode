# 一、题目
我们正在玩一个猜数游戏，游戏规则如下：     
1. 我从 1 到 n 之间选择一个数字。
2. 你来猜我选了哪个数字。
3. 如果你猜到正确的数字，就会 赢得游戏 。
4. 如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。
5. 每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。
     
     
给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。    
    
**示例 1：**     
```
输入：n = 10
输出：16
解释：制胜策略如下：
- 数字范围是 [1,10] 。你先猜测数字为 7 。
    - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。
    - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。
        - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。
        - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。
        - 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。
    - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。
        - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。
        - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。
            - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5 。
            - 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
            - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
        - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。
            - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $1 。
            - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。
在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。
```
**示例 2：**     
```
输入：n = 1
输出：0
解释：只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。
```
**示例 3：**    
```
输入：n = 2
输出：1
解释：有两个可能的数字 1 和 2 。
- 你可以先猜 1 。
    - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。
    - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。
最糟糕的情况下，你需要支付 $1 。
```
**提示：**    
- 1 <= n <= 200
     
     
来源：力扣（LeetCode）    
链接：[https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii)     
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。    
# 二、分析及代码    
## 1. 动态规划
### （1）思路
对于这类问题，可以分析从小区间向大区间的状态转移方式，结合动态规划方法求解。    
     
设计一个数组 dp，其中 dp[i][j] 表示在 [i, j] 范围内能够确保获胜的最小现金数，则对 [i, j] 区间内的任意 k，状态转移方程可表示为 dp[i][j] = min(dp[i][j], k + max(dp[i][k - 1], dp[k + 1][j]))。    

遍历所有 i < j 的区间，最终得到 dp[1][n] 就是待求的解。     
### （2）代码
```cpp
class Solution {
public:
    int getMoneyAmount(int n) {
        vector<vector<int>> dp(n + 1, vector<int>(n + 1));//dp[i][j]表示在[i,j]范围内能够确保获胜的最小现金数
        for (int i = n - 1; i > 0; i--) {//从后向前遍历左边界i
            for (int j = i + 1; j <= n; j++) {//从前向后遍历右边界j
                dp[i][j] = INT_MAX;//i!=j时dp[i][j]初始值设为最大
                for (int k = i; k < j; k++) {//遍历可能选择的数字k
                    dp[i][j] = min(dp[i][j], k + max(dp[i][k - 1], dp[k + 1][j]));//更新确保获胜的最小现金数
                }
            }
        }
        return dp[1][n];//[1,n]区间内能够确保获胜的最小现金数就是所求解
    }
};
```
### （3）结果
执行用时 ：152 ms，在所有 C++ 提交中击败了 36.96% 的用户；    
内存消耗 ：8 MB，在所有 C++ 提交中击败了 53.51% 的用户。      
# 三、其他
暂无。  
