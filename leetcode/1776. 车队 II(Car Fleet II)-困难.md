# 一、题目
在一条单车道上有 n 辆车，它们朝着同样的方向行驶。给你一个长度为 n 的数组 cars ，其中 cars[i] = [positioni, speedi] ，它表示：     
- positioni 是第 i 辆车和道路起点之间的距离（单位：米）。题目保证 positioni < positioni+1 。
- speedi 是第 i 辆车的初始速度（单位：米/秒）。
       
简单起见，所有车子可以视为在数轴上移动的点。当两辆车占据同一个位置时，我们称它们相遇了。一旦两辆车相遇，它们会合并成一个车队，这个车队里的车有着同样的位置和相同的速度，速度为这个车队里 最慢 一辆车的速度。     
请你返回一个数组 answer ，其中 answer[i] 是第 i 辆车与下一辆车相遇的时间（单位：秒），如果这辆车不会与下一辆车相遇，则 answer[i] 为 -1 。答案精度误差需在 10^-5 以内。     
     
**示例 1：**     
```
输入：cars = [[1,2],[2,1],[4,3],[7,2]]
输出：[1.00000,-1.00000,3.00000,-1.00000]
解释：经过恰好 1 秒以后，第一辆车会与第二辆车相遇，并形成一个 1 m/s 的车队。经过恰好 3 秒以后，第三辆车会与第四辆车相遇，并形成一个 2 m/s 的车队。
```
**示例 2：**
```
输入：cars = [[3,4],[5,4],[6,3],[9,1]]
输出：[2.00000,1.00000,1.50000,-1.00000]
```
**提示：**     
- 1 <= cars.length <= 10^5
- 1 <= positioni, speedi <= 10^6
- positioni < positioni+1
      
来源：力扣（LeetCode）    
链接：[https://leetcode-cn.com/problems/car-fleet-ii](https://leetcode-cn.com/problems/car-fleet-ii)     
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。     
# 二、分析及代码    
## 1. 单调栈
### （1）思路
当后一辆车与前一辆车相遇后，后车速度变为与前车一致（前车速度一定慢于后车，否则不会相遇），位置与前车相同，等效于后车已消失，之后可不再考虑。      
因此一辆车是否与前车相遇，只与它的前车有关，而与后车无关，在这一基础上，可从右向左考虑各车的相遇问题。    
可以设计一个单调栈，存储当前车右侧且从快到慢的车(的编号)，其他未进入栈的车已被栈中的车合并为车队。当考虑新一辆车时，只需依次考虑该车与栈顶各车是否能够相遇即可。     
### （2）代码
```java
class Solution {
    public double[] getCollisionTimes(int[][] cars) {
        int n = cars.length;
        double[] ans = new double[n];
        Arrays.fill(ans, -1);
        Stack<Integer> sta = new Stack<>();//单调栈，存储当前car右侧且从快到慢的车(的编号)，其他未进入栈的车已被栈中的车合并为车队
        for (int i = n - 1; i >= 0; i--) {//从右到左依次处理
            while (!sta.isEmpty()) {
                if (cars[sta.peek()][1] >= cars[i][1] || (ans[sta.peek()] > 0 && (double)(cars[sta.peek()][0] - cars[i][0]) / (cars[i][1] - cars[sta.peek()][1]) > ans[sta.peek()]))//栈顶车速度大于当前车，或被合并时间早于被当前车追上时间，不会被当前及更左的车追上
                    sta.pop();
                else//栈顶车速度小于当前车，可能相遇
                    break;//当前栈顶满足要求，跳出循环
            }
            if (!sta.isEmpty())//当前车和栈顶车相遇
                ans[i] = (double)(cars[sta.peek()][0] - cars[i][0]) / (cars[i][1] - cars[sta.peek()][1]);
            sta.push(i);//当前车有可能和左边车相遇，加入栈
        }
        return ans;
    }
}
```
### （3）结果
执行用时 ：65 ms，在所有 Java 提交中击败了 100.00% 的用户；    
内存消耗 ：99.1 MB，在所有 Java 提交中击败了 100.00% 的用户。      
（目前提交用户量不足，无排名）
# 三、其他
暂无。  
