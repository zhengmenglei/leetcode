# 一、题目
给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。     
     
h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 N - h 篇论文每篇被引用次数 不超过 h 次。    
    
例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。    
    
**示例：**    
```
输入：citations = [3,0,6,1,5]
输出：3 
解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。
```
提示：如果 h 有多种可能的值，h 指数是其中最大的那个。     
    
来源：力扣（LeetCode）     
链接：[https://leetcode-cn.com/problems/h-index](https://leetcode-cn.com/problems/h-index)      
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。    
# 二、分析及代码    
## 1. 计数排序
### （1）思路
若研究者论文总数为 n，根据 h 指数的定义可以确定，h <= n，因此引用次数超过 n 的论文所超出部分对 h 指数是无效的。    
结合这一特点，可设计一个长度为 n + 1 的数组，统计各引用次数对应的论文数，并将引用大于 n 的论文按 n 次统计。再从后向前遍历该数组，寻找最大的 h 指数，从而在 O(n) 时间复杂度内完成求解。     
### （2）代码
```java
class Solution {
    public int hIndex(int[] citations) {
        int n = citations.length;//论文总数

        //统计各引用次数对应的论文数，大于n次的计为n
        int[] count = new int[n + 1];
        Arrays.fill(count, 0);
        for (int c : citations) {
            if (c >= n)
                count[n]++;
            else
                count[c]++;
        }

        //获得最大的h指数
        int h = n, c = count[n];//当前h值，引用不小于h的论文数量
        while (c < h)
            c += count[--h];
        return h;
    }
}
```
### （3）结果
执行用时 ：0 ms，在所有 Java 提交中击败了 100.00% 的用户；    
内存消耗 ：36.4 MB，在所有 Java 提交中击败了 23.06% 的用户。      
# 三、其他
暂无。  
