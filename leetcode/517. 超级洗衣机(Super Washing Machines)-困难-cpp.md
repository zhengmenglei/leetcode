# 一、题目
假设有 n 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。    
    
在每一步操作中，你可以选择任意 m (1 <= m <= n) 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。    
    
给定一个整数数组 machines 代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 最少的操作步数 。如果不能使每台洗衣机中衣物的数量相等，则返回 -1 。    
    
**示例 1：**    
```
输入：machines = [1,0,5]
输出：3
解释：
第一步:    1     0 <-- 5    =>    1     1     4
第二步:    1 <-- 1 <-- 4    =>    2     1     3    
第三步:    2     1 <-- 3    =>    2     2     2   
```
**示例 2：**     
```
输入：machines = [0,3,0]
输出：2
解释：
第一步:    0 <-- 3     0    =>    1     2     0    
第二步:    1     2 --> 0    =>    1     1     1     
```
**示例 3：**     
```
输入：machines = [0,2,0]
输出：-1
解释：
不可能让所有三个洗衣机同时剩下相同数量的衣物。
```
**提示：**     
- n == machines.length
- 1 <= n <= 10^4
- 0 <= machines[i] <= 10^5
     
       
来源：力扣（LeetCode）     
链接：[https://leetcode-cn.com/problems/super-washing-machines](https://leetcode-cn.com/problems/super-washing-machines)     
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。    
# 二、分析及代码    
## 1. 贪心
### （1）思路
首先，根据衣服总数是否能够被洗衣机数整除，判断最终每台洗衣机中的衣物数量是否可以达到相等。   
     
根据贪心思路，最终的最小操作步数可能为某一台或一侧洗衣机中超出预期的衣服数量或总数。   
    
因此，从左至右遍历每台洗衣机，则答案 ans = max(当前洗衣机中超出平均值的衣服数，已遍历过的洗衣机中超出/不足平均值的衣服总数)。    
### （2）代码
```cpp
class Solution {
public:
    int findMinMoves(vector<int>& machines) {
        int total = accumulate(machines.begin(), machines.end(), 0), n = machines.size();//衣服总数，洗衣机数
        if (total % n != 0) {//衣服总数不能被洗衣机数整除，说明无法使每台洗衣机中的衣物数量相等
            return -1;
        }

        int avg = total / n, sum = 0, ans = 0;//最终每台洗衣机中的衣服数量，当前左侧洗衣机中超出/不足平均值的衣服数量，答案
        for (int i = 0; i < n; i++) {//从左至右遍历每台洗衣机
            int num = machines[i] - avg;//当前洗衣机中超出平均值的衣服数量，其值可能为最大操作步数
            ans = max(ans, num);
            sum += num;//当前一侧洗衣机中总共超出/不足平均值的衣服数量，其绝对值也可能为最大操作步数
            ans = max(ans, abs(sum));
        }
        return ans;
    }
};
```
### （3）结果
执行用时 ：12 ms，在所有 C++ 提交中击败了 42.94% 的用户；    
内存消耗 ：12.6 MB，在所有 C++ 提交中击败了 83.62% 的用户。      
# 三、其他
暂无。  
