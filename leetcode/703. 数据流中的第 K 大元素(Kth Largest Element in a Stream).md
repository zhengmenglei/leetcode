# 一、题目
设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。     
       
请实现 KthLargest 类：     
- KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。
- int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。
     
   
**示例：**    
```
输入：
["KthLargest", "add", "add", "add", "add", "add"]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
输出：
[null, 4, 5, 5, 8, 8]

解释：
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8
```
**提示：**    
- 1 <= k <= 104
- 0 <= nums.length <= 104
- -104 <= nums[i] <= 104
- -104 <= val <= 104
- 最多调用 add 方法 104 次
- 题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素
     
来源：力扣（LeetCode）     
链接：[https://leetcode-cn.com/problems/kth-largest-element-in-a-stream](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream)     
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。    
# 二、分析及代码    
## 1. 堆（优先队列）
### （1）思路
设计一个小顶堆（优先队列），依次插入数据，当其中元素个数大于 k 时，弹出最小元素。此时堆顶即为第 k 大的元素。      
### （2）代码
```java
class KthLargest {
    int k;
    PriorityQueue<Integer> pq;

    public KthLargest(int k, int[] nums) {
        this.k = k;
        pq = new PriorityQueue<>();
        for (int num : nums)
            add(num);
    }
    
    public int add(int val) {
        pq.offer(val);
        if (pq.size() > k)
            pq.poll();
        return pq.peek();
    }
}
```
### （3）结果
执行用时 ：18 ms，在所有 Java 提交中击败了 88.31% 的用户；    
内存消耗 ：43.7 MB，在所有 Java 提交中击败了 61.50% 的用户。      
# 三、其他
暂无。  
