# 一、题目
Alice 和 Bob 玩一个游戏，两人轮流操作， Alice 先手 。      
       
总共有 n 个石子排成一行。轮到某个玩家的回合时，如果石子的数目 大于 1 ，他将执行以下操作：      
1. 选择一个整数 x > 1 ，并且 移除 最左边的 x 个石子。
2. 将 移除 的石子价值之 和 累加到该玩家的分数中。
3. 将一个 新的石子 放在最左边，且新石子的值为被移除石子值之和。
         
         
当只剩下 一个 石子时，游戏结束。         
          
Alice 和 Bob 的 分数之差 为 (Alice 的分数 - Bob 的分数) 。 Alice 的目标是 最大化 分数差，Bob 的目标是 最小化 分数差。          
           
给你一个长度为 n 的整数数组 stones ，其中 stones[i] 是 从左边起 第 i 个石子的价值。请你返回在双方都采用 最优 策略的情况下，Alice 和 Bob 的 分数之差 。           
          
**示例 1：**       
```
输入：stones = [-1,2,-3,4,-5]
输出：5
解释：
- Alice 移除最左边的 4 个石子，得分增加 (-1) + 2 + (-3) + 4 = 2 ，并且将一个价值为 2 的石子放在最左边。stones = [2,-5] 。
- Bob 移除最左边的 2 个石子，得分增加 2 + (-5) = -3 ，并且将一个价值为 -3 的石子放在最左边。stones = [-3] 。
两者分数之差为 2 - (-3) = 5 。
```
**示例 2：**      
```
输入：stones = [7,-6,5,10,5,-2,-6]
输出：13
解释：
- Alice 移除所有石子，得分增加 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 ，并且将一个价值为 13 的石子放在最左边。stones = [13] 。
两者分数之差为 13 - 0 = 13 。
```
**示例 3：**      
```
输入：stones = [-10,-12]
输出：-22
解释：
- Alice 只有一种操作，就是移除所有石子。得分增加 (-10) + (-12) = -22 ，并且将一个价值为 -22 的石子放在最左边。stones = [-22] 。
两者分数之差为 (-22) - 0 = -22 。
```
**提示：**     
- n == stones.length
- 2 <= n <= 10^5
- -10^4 <= stones[i] <= 10^4
         
         
来源：力扣（LeetCode）          
链接：[https://leetcode-cn.com/problems/stone-game-viii](https://leetcode-cn.com/problems/stone-game-viii)        
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。         
# 二、分析及代码    
## 1. 前缀和 + 动态规划
### （1）思路
玩家们的操作等价于：一名玩家在石子值前缀和数组中选取第 i 个值，然后另一玩家在 [i + 1, n - 1] 区间内选取下一前缀和数值。     
因为在同一条件下 Alice 和 Bob 的操作完全相同，设计一个动态规划数组表示玩家的最优策略即可。     
设计动态规划数组 dp[i]，表示区间 [i, n - 1] 范围内能够获得的最大分数差，则对位置 i，根据是否选取第 i 个前缀和可得到状态转移方程 dp[i] = Math.max(dp[i + 1], preSum[i] - dp[i + 1])。      
由于第 n - 1 个前缀和一定会被选取，可从后向前进行动态规划；又因为第一次选取操作时只能从第 2 个石子开始，Alice 的有效起始点为 dp[1]。       
### （2）代码
```java
class Solution {
    public int stoneGameVIII(int[] stones) {
        int n = stones.length;
        int[] preSum = new int[n], dp = new int[n];//石子值前缀和、动态规划数组，表示区间[i,n-1]范围内能够获得的最大分数差
        //计算前缀和
        preSum[0] = stones[0];
        for (int i = 1; i < n; i++)
            preSum[i] = preSum[i - 1] + stones[i];
        //动态规划
        dp[n - 1] = preSum[n - 1];
        for (int i = n - 2; i >= 0; i--)
            dp[i] = Math.max(dp[i + 1], preSum[i] - dp[i + 1]);//状态转移为 不选取第i个石子/选取第i个石子得到分数差的较大值
        return dp[1];//要求移除石子数>1，即Alice的有效起始点为dp[1]
    }
}
```
### （3）结果
执行用时 ：5 ms，在所有 Java 提交中击败了 100.00% 的用户；    
内存消耗 ：52.5 MB，在所有 Java 提交中击败了 100.00% 的用户。      
（目前提交用户量不足，暂无排名）       
# 三、其他
暂无。  
