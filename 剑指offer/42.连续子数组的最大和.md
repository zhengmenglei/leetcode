# 一、题目
HZ 偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后，他又发话了：在古老的一维模式识别中，常常需要计算连续子向量的最大和，当向量全为正数的时候，问题很好解决。但是，如果向量中包含负数，是否应该包含某个负数，并期望旁边的正数会弥补它呢？例如：{6,-3,-2,7,-15,1,2,2}，连续子向量的最大和为 8（从第 0 个开始，到第 3 个为止）。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)  
# 二、分析及代码
## 1. 辅助标志
### （1）思路
设计两个辅助数据，一个记录当前最大连续子序列的和，一个记录当前位置子序列最大累加值。   
遍历所给数组，若当前位置子序列最大累加值和当前数据的和小于 0，清空累加值的值为 0，否则继续累加。若当前数字为正整数，判断是否需更新最大连续子序列和的记录值。   
### （2）代码
```java
public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
        if (array == null || array.length == 0)
            return 0;
        int ans = array[0], sum = 0;
        for (int i = 0; i < array.length; i++) {
            sum = Math.max(sum, 0);
            sum += array[i];
            ans = Math.max(ans, sum);
        }
        return ans;
    }
}
```
### （3）结果
运行时间：14ms，占用内存：9284k。 
# 三、其他
暂无。 
