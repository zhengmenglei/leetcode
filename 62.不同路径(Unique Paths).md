# 一、题目
一个机器人位于一个 m x n 网格的左上角。  
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。  
问总共有多少条不同的路径？  
  
例如，一个7 x 3 的网格。有多少可能的路径？  
说明：m 和 n 的值均不超过 100。  
  
示例 1:  
```c++
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```
示例 2:  
```c++ 
输入: m = 7, n = 3
输出: 28
```
来源：力扣（LeetCode）  
链接：[https://leetcode-cn.com/problems/unique-paths](https://leetcode-cn.com/problems/unique-paths)  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  
# 二、分析及代码
## 1. 动态规划
### （1）思路
这题可以利用动态规划求解：  
每个位置可以由 左边 或 上边 到达， 即  
每个位置的路径数 = 左边路径数 + 上边路径数。  
可以按行依次遍历计算，因此只需一个长度为m的数组记录即可。  
### （2）代码
```c
class Solution {
public:
    int uniquePaths(int m, int n) {
        int dp[m];
        for (int i = 0; i < m; i++)
            dp[i] = 1;
        for (int j = 0; j < n - 1; j++)
            for (int i = 1; i < m; i++)
                dp[i] = dp[i - 1] + dp[i];
        return dp[m - 1];        
    }
};
```
### （3）结果
执行用时 ：4 ms, 在所有 C++ 提交中击败了 72.72% 的用户；  
内存消耗 ：8 MB, 在所有 C++ 提交中击败了 90.10% 的用户。  
## 2. 组合计算
### （1）思路
路径选取问题可抽象为：从 (m + n - 2) 条路径中，选取 (n - 1) 条向下的路径（或 (m - 1) 条向右的路径）；  
即结果为 C( m + n - 2, m - 1) = (m + n - 2)! / ((m - 1)! (n - 1)!)  
由于实现过程涉及阶乘，极易溢出，只能不断在中途相除，因此这种方法实现过程实际上反而比动态规划繁琐。  
# 三、其他
暂无。  
